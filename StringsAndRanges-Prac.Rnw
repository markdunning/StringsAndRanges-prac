%\VignetteIndexEntry{Strings and Ranges Practical}
%\VignettePackage{Course}
%\VignetteEngine{knitr::knitr}

% To compile this document
% library('knitr'); rm(list=ls()); knit('DESeq2.Rnw')

\documentclass[12pt]{article}
\usepackage{wasysym,marvosym}
\newcommand{\usecase}{\textit{\textbf{Use Case: }}}
\newcommand{\notebell}{\bell}
\newcommand{\noteright}{\Pointinghand}
\newcommand{\textinfo}{\Info}
<<knitr, echo=FALSE, results="hide">>=
library("knitr")
opts_chunk$set(tidy=FALSE,dev="png",fig.show="hide",
               fig.width=4,fig.height=4.5,
               message=FALSE,eval=FALSE)
@ 

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@


\title{Representing sequencing data in Bioconductor}

\author{Mark Dunning \email{mark.dunning@cruk.cam.ac.uk}}
\date{Last modified: \today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}






\maketitle


\tableofcontents

\section*{Introduction}

The purpose of this practical is to familiarise you with the concept of strings and ranges in Bioconductor. These are fundamental objects upon which many analysis tools for next-generation sequencing data are built-upon.

\textbf{In order for the example code to run, you must be in the {\tt Practicals} directory.}

<<options, results="hide", echo=FALSE>>=
options(digits=3, width=80, prompt=" ", continue=" ")
@



\section{Accessing Genome Sequence}

\usecase See what genomes are currently available through Bioconductor

<<>>=
library(BSgenome)
available.genomes()
@

Load the package that contains a representaion of the Human Genome version hg19. 
<<>>=
library(BSgenome.Hsapiens.UCSC.hg19)
hg19 <- BSgenome.Hsapiens.UCSC.hg19
@


What chromosomes are available?

\usecase How many chromosomes does the package have sequences for?

<<>>=
seqnames(hg19)
names(hg19)
length(seqnames(hg19))
@

\usecase Get the sequence for Chromosome X. How many bases long is the sequence?

<<>>=
hg19[["chrX"]]
@

\usecase What is the length of each chromosome?

<<>>=
chrLen <- unlist(lapply(seqnames(hg19), function(x) length(hg19[[x]])))
chrLen
names(chrLen) <- seqnames(hg19)

@

<<>>=
chrLen <- chrLen[chrLen>5000000]
barplot(chrLen)
@


\subsection{Alphabet Frequencies}

<<>>=
alphabetFrequency(hg19[["chr22"]],baseOnly=TRUE)
alphabetFrequency(hg19[["chr22"]],baseOnly=TRUE) / chrLen["chr22"]
@


<<>>=
library(GenomicRanges)
rngs <- GRanges("chr22",IRanges(start=seq(1, chrLen["chr22"]-100000,100000),width=100000))
winSeq <- getSeq(hg19,rngs)
winAf <- alphabetFrequency(winSeq,baseOnly=TRUE)
@


<<>>=
plot(winAf[,1] ,type="n")
points(winAf[,1], pch="A",col="red")
points(winAf[,2], pch="C", col="green")
points(winAf[,3], pch="G", col="blue")
points(winAf[,4], pch="T", col="purple")
points(winAf[,5], pch="N", col="black")

@

\usecase Find which windows have over 60\% GC content. Which ranges does these correspond to?

<<>>=
gcPerc <- (winAf[,2] + winAf[,3]) / 100000
hist(gcPerc)
winAf[gcPerc > 0.6,]
rngs[gcPerc > 0.6]
@

\subsection{Finding sequences}



<<>>=
s1 <- "aaaatgcagtaacccatgccc"
matchPattern("atg", s1)
@

Masked regions on the genome can be identified by long stretches of N bases

\usecase Use the \Rfunction{matchPattern} function to find potential start sites in Chromosome 22

<<>>=
n.matches <- matchPattern("NNNNNNNNNN", hg19[["chr22"]])
maskRegions <- IRanges(start=start(n.matches),end=end(n.matches))
@

\usecase create a set of non-overlapping intervals using \Rfunction{reduce}
<<>>=
maskRegions <- reduce(maskRegions)
@

\subsection{Working with Gene sequences}

We are given a text file containing the positions of genes on chromosome 22. Our task is to read this file, produce a Genomic Ranges representation of the data and start to explore the sequences of the genes.

<<>>=
chr22Info <- read.delim("hg19.chr22Genes.txt")
head(chr22Info)
@

Creating a GRanges object

<<>>=
chr22Rng <- GRanges(chr22Info[,4], IRanges(chr22Info[,3], chr22Info[,5]))
@

However, we might want to keep track of the name of each gene. We can do this be using extra arguments
<<>>=
chr22Rng <- GRanges(xInfo[,4], IRanges(xInfo[,3], xInfo[,5]),
                    GeneSymbol=xInfo[,2],EntrezID=xInfo[,1])
@

The extra information forms part of the element metadata. To see what metadata we have stored currently, we can use the mcols function. The actual variables can be accessed using the \$ operator with the name of the variable.

\usecase See what metadata is stored with the ranges object. Print out the gene symbols


<<>>=
mcols(chr22Rng)
chr22Rng$GeneSymbol
@


\usecase Find the ID of the longest and shortest exon

<<>>=
id.of.longest <- which.max(width(chr22Rng))
chr22Rng[id.of.longest]
id.of.shortest <- which.min(width(chr22Rng))
chr22Rng[id.of.shortest]
@

Genes can have multiple entries, depending on how many different transcripts are defined for them.

\usecase Which gene has the most number of transcrips
<<>>=
sort(table(chr22Rng$EntrezID))
most.transcripts <- names(sort(table(chr22Rng$EntrezID),decreasing=TRUE))[1]
chr22Rng[which(chr22Rng$EntrezID  == most.transcripts)]
@


Lets' find out how many genes can be found in the windows we defined earlier

<<>>=
chr22Rng <- sort(chr22Rng)
@

\usecase Can you explain the warning message in the following?

<<>>=
findOverlaps(rngs, chr22Rng)
@

<<>>=
chr22Rng <- renameSeqlevels(chr22Rng, value=c("22"="chr22"))
findOverlaps(rngs, chr22Rng)
@

<<>>=
nOverlaps <- countOverlaps(rngs,chr22Rng)
deserts <- rngs[which(nOverlaps==0)]
deserts
@

<<>>=
which.max(nOverlaps)
mostGenes <- rngs[which.max(nOverlaps)]
mostGenes
chr22Rng[chr22Rng %over% mostGenes]
@

\subsection{Retrieving the sequence for a gene}

We can of course retrieve the full sequence for a gene

<<>>=
chr22seqs <- getSeq(hg19, chr22Rng)
chr22seqs
@

However, there are options available for when we don't want the full sequence, or want to obtain sequences beyond that defined by the gene.

Get flanking sequences.....

<<>>=
chr22Flanks <- flank(chr22Rng,100)
chr22FlankSeq <- getSeq(hg19,chr22Flanks)
@

<<>>=
resize(chr22Rng, 50)
getSeq(hg19,resize(chr22Rng, 50))
@

\section{Reading bam alignments}
An obvious application of the \Rclass{IRanges} and \Rclass{GRanges} infrastructure is to facilitate the storage and querying of genomic alignments. The \Biocpkg{Rsamtools} is one such package that allows aligned reads to be imported into R. However, we will use functionality from the \Biocpkg{GenomicRanges} package for simplicity. In your own time, feel free to check out the \Rfunction{scanBam} function in \Biocpkg{Rsamtools}. 

An example bam file is provided in the {\tt exampleData} folder.


\usecase
Read the example bam file into R as a \Robject{GRanges} object. How many reads are in the file?


<<>>=
library(GenomicAlignments)
mybam <- "exampleData/NA19914.chr22.bam"
bam <- readGAlignments(file=mybam)
bam
@

The essential information from the bam file has been imported. Finer grain control over what data are read can be achieved by using the {\tt param} argument. The object returned by \Rfunction{readGAlignments} acts like a data frame, with columns that can be assessed by a number of convenience functions \Rfunction{strand}, \Rfunction{width}, \Rfunction{cigar}, \Rfunction{start}, \Rfunction{end}

\usecase
Use accessor ({\Rfunction{strand}, \Rfunction{width}, \Rfunction{cigar}, \Rfunction{start}, \Rfunction{end}) functions to explore the \Robject{bam} object.


<<>>=
table(strand(bam))
table(width(bam))
range(start(bam))
head(sort(table(cigar(bam)), decreasing=TRUE))
@

<<>>=
bam <- readGAlignments(file=mybam, param=ScanBamParam(what=c("seq","mapq","flag")))
@

Mapping qualities......

<<>>=
hist(mcols(bam)$mapq)
bam[mcols(bam)$mapq==0]
@


Cigar.....

<<>>=
bestReads <- bam[cigar(bam) == "68M"]
bestRngs <- GRanges("chr22", ranges(bestReads))
gSeqs <- getSeq(hg19, bestRngs)
alignedSeqs <- mcols(bestReads)$seq
gSeqs[1:5]
alignedSeqs[1:5]
sum(alignedSeqs == gSeqs)
@


Several range operations will work on the GappedAlignment object, such as \Rfunction{coverage}.


\usecase
Create a coverage vector and identify regions with more than 1000 reads covering


<<>>=
cov <- coverage(bam)
HighCov <- ranges(slice(cov, 1000))[["22"]]
HighCov
@



An efficient way of creating a subset of reads based on genomic location is to use the overlapping functionality that we saw previously.

\usecase
Restrict the alignments to just those in the high-coverage (say > 1000 reads) regions


<<>>=
HighCovGR <- GRanges("22", IRanges(start = start(HighCov), end=end(HighCov)))
bam.sub <- bam[bam %over% HighCovGR,]
bam.sub
length(bam.sub)

@


\usecase
Use \Rfunction{findOverlaps} and \Rfunction{countOverlaps} to find out how many reads align to these high-coverage regions.

<<>>=
findOverlaps(HighCovGR,bam)
countOverlaps(HighCovGR,bam)
@


\subsection{Reading a particular genomic region}

If we were only really interested in a relatively small region of a chromosome, then another option would be to read the whole bam file, especially if the file can run to several gigabytes in size. As the bam file is indexed, we can easily jump to the location we are interested in. This is achieved by using the \Rfunction{ScanBamParam} function with the GRanges object for the region we want to read. See the help page on \Rfunction{ScanBamParam} for more details about how to customise how to read a bam file.




\usecase
Read a portion of the bam file corresponding to the high-coverage regions rather the whole file. Verify that the same reads as the previous exercise are returned.


<<>>=
bam.sub2 <- readGAlignments(file=mybam,use.names=TRUE, 
param=ScanBamParam(which=HighCovGR))
length(bam.sub)
length(bam.sub2)
all(names(bam.sub) == names(bam.sub2))
@

The previous two exercises have restricted the analysis to reads that fall inside any of the high-coverage regions. However, we might want to look at each region separately.


\usecase
Classify the reads according to which high-coverage region they belong to. Verify that the correct number of overlapping reads are returned.


<<>>=
names(HighCovGR) <- paste("Region", 1:length(HighCov),sep="")
regionLst <- split(HighCovGR, names(HighCovGR))

splitRegions <- lapply(regionLst, function(x) bam[bam %over% x])

lapply(splitRegions,length)

@



\end{document}
