%\VignetteIndexEntry{Strings and Ranges Practical}
%\VignettePackage{Course}
%\VignetteEngine{knitr::knitr}

% To compile this document
% library('knitr'); rm(list=ls()); knit('DESeq2.Rnw')

\documentclass[12pt]{article}
\usepackage{wasysym,marvosym}
\newcommand{\usecase}{\textit{\textbf{Use Case: }}}
\newcommand{\notebell}{\bell}
\newcommand{\noteright}{\Pointinghand}
\newcommand{\textinfo}{\Info}
<<knitr, echo=FALSE, results="hide">>=
library("knitr")
opts_chunk$set(tidy=FALSE,dev="png",fig.show="hide",
               fig.width=4,fig.height=4.5,
               message=FALSE,eval=FALSE)
@ 

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@


\title{Introduction to Strings and Ranges in Bioconductor}

\author{Mark Dunning \email{mark.dunning@cruk.cam.ac.uk}}
\date{Last modified: \today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}






\maketitle


\tableofcontents

\section{Introduction}

The purpose of this practical is to familiarise you with the concept of strings and ranges in Bioconductor. These are fundamental objects upon which many analysis tools for next-generation sequencing data are built-upon.

\textbf{In order for the example code to run, you must be in the {\tt Practicals} directory.}

<<options, results="hide", echo=FALSE>>=
options(digits=3, width=80, prompt=" ", continue=" ")
@


\section{Strings}


\subsection{Strings in R}
Before explaining the specialised string manipulation features available in Bioconductor, we will use some featuers from the R base code. Written long before the age of next-generation sequencing, these are not designed to deal with large volumes of data. Nevertheless, some useful operations are possible.

Here we will define a function to create a random set of DNA sequences with configurable lengths that we will work with in the following exercises. Each string is a separate item in a vector, so the usual subset conventions apply.


\usecase
Use the \Rfunction{randomDNAString} function, defined in the scripts folder, to construct 500 random sequence of A, T, G,, C. By default each sequence will be of length between 10 and 20 [How do you know this?] . Print out the first five strings.
<<>>=

source("scripts/randomDNAString.R")
randomDNAString
rand <- randomDNAString()
rand
rand[1:5]
@



\usecase
What is the distribution of the number of characters in each string? Select the strings with exactly 10 characters.

<<>>=
nchar(rand)
summary(nchar(rand))
hist(nchar(rand))
rand[nchar(rand)== 10]
@



\usecase
How many occurences of the the string AAA are there? Replace AAA with the string NNN


<<>>=
rand[grep("AAAA", rand)]

gsub("AAA", "NNN", rand)

@


\usecase
Subset each string to the first 3 characters. What is the most common 3-letter string?


<<>>=
rand.sub <- substr(rand, 1,3)
rand[1:10]
rand.sub[1:10]
sort(table(substr(rand, 1,3)))

@


\subsection{Strings in Bioconductor; Biostrings}
The \Biocpkg{Biostrings} package in Bioconductor provides tools for working with sequences. The packages implements the base string manipulation functions in R, plus much more besides. The functions are written in a memory-efficient manner and the implemented object-types are the foundation upon which more-complex operations are built-upon. The basic object type that we will use is the \Rclass{DNAStringSet}, which is a collection of the more basic \Rclass{DNAString}. The subsetting of \Rclass{DNAStringSet} object operates as you would expect.



\usecase
Create a set of 1000 DNA sequences that vary between length 5 and 100 and use this to make a DNAStringSet instance


<<>>=
library(Biostrings)
rand2 <- randomDNAString(N=1000,minL=5,maxL=100)
myseq <- DNAStringSet(rand2)
myseq

@

You will notice that the object is displayed in a more convenient way to the random string, and the length (width) of each string is displayed alongside it. The width of each string can be accessed by the \Rfunction{width} function. The \Rclass{DNAStringSet} objects can be subset in the same ways as standard R vectors.


\usecase
Create a summary of the string length distributions. Select all strings with less than 10 characters.



<<>>=
summary(width(myseq))
hist(width(myseq))
myseq[width(myseq)<10]
as.character(myseq[width(myseq)<10])
@

Many standard R functions have also been adapted to work for the \Rclass{DNAStringSet}. These include \Rfunction{sort}, \Rfunction{head}, \Rfunction{rev} and \Rfunction{tail}. 

\usecase
Explore the behaviour of the \Rfunction{subseq}, \Rfunction{sort}, \Rfunction{head}, \Rfunction{tail} and \Rfunction{rev}

<<>>=
subseq(myseq, 1, 3)
sort(myseq)
head(myseq)
tail(myseq)
head(rev(myseq))
@


Another common operation is to be able to count the ocurrences of letters in each string. This could be achieved by use of the \Rfunction{table} function, but a more efficient implementation is provided in \Rfunction{alphabetFrequency}. Calculating the frequency of 2-mer and 3-mers is also possible.


\usecase
Calculate the frequencing of letters in each string and make sure that you understand the dimensions of the \Rfunction{alphabetFrequency} output. Check for any biases in base distribution. Do any sequences not contain any As?


<<letterFreqency>>=
af <- alphabetFrequency(myseq, baseOnly=TRUE)
dim(af)
head(af)
myseq[af[,1] ==0,]
boxplot(af)
boxplot(dinucleotideFrequency(myseq),las=2)
boxplot(trinucleotideFrequency(myseq),horizontal=T,las=2)

@


\usecase
Modify the alphabet frequency table so that it accounts the different string lengths


<<>>=
af2 <- alphabetFrequency(myseq, baseOnly=TRUE)/width(myseq)
boxplot(af2)
@


\usecase
Calculate the percentage of Gs and Cs for each string. Find any strings with greater than 75\% GC bases.


<<>>=
gcCounts <- af2[,"C"] + af2[,"G"]
summary(gcCounts)
myseq[gcCounts > 0.75]
@


\usecase
Reverse, complement, and translate the sequences


<<>>=
reverse(myseq)
reverseComplement(myseq)
translate(myseq)
@

After manipulating our set of sequences, we may wish to export them for analysis in some external tool. A common format for sequence representation is \textit{fasta} which usually has the file extension {\tt .fa}.


\usecase
Write your sequences out to a file


<<>>=
writeXStringSet(myseq, file="myseq.fa")
@


\section{Fastq analysis with ShortRead}
We are now going to deal with real, rather than simulated, data. The \Biocpkg{ShortRead} packages is one of the many Bioconductor packages that relies on \Biocpkg{Biostrings} for its core functionality. 

The FASTQ format is now the industry-standard way that sequencers produce output. 

\begin{verbatim}@SRR031724.1 HWI-EAS299_4_30M2BAAXX:5:1:1513:1024 length=37
GTTTTGTCCAAGTTCTGGTAGCTGAATCCTGGGGCGC
+SRR031724.1 HWI-EAS299_4_30M2BAAXX:5:1:1513:1024 length=37
IIIIIIIIIIIIIIIIIIIIIIIIIIII+HIIII<IE
\end{verbatim}

Each read is given a unique identifier that is repeated on the first and third lines, although it can be omitted from the third line. Typically this identifier includes the name of the sequencing machine, lane, tile and coordinates of the read. The second and fourth lines are the nucleotides and quality scores respectively. The quality score is represented as a letter from the ASCII alphabet, with letters higher in the alphabet representing a higher quality and more-confident base-call.


\begin{verbatim}
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO
PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
\end{verbatim}

Reading the fastq file into R allows quality control steps to be performed and the generation of the type of plots that are produced by the fastqc tool \footnote{\tt http://www.bioinformatics.babraham.ac.uk/projects/fastqc/}. 



\usecase

Remind yourself of the format of a fastq file by reading the first few lines of example file that we have provided in the {\tt exampleData} folder. Then, read the file using the \Biocpkg{ShortRead} package. How many sequencing reads does the file contain?



<<>>=

myfile <- "exampleData/sample.fq"

readLines(myfile,n=10)
library(ShortRead)
fq <- readFastq(myfile)
fq
@
\textinfo To read your own fastq file into ShortRead, simply change the value of the \Robject{myfile} variable to point to the fastq file that you want to read. If you have trouble typing the path to the file, try the \Rfunction{file.choose} function.\\



The \Robject{fq} object is of type \Rclass{ShortReadQ} and particular aspects of the object can be accessed by the \Rfunction{sread}, \Rfunction{quality} and \Rfunction{width} functions.

\usecase
Explore the ShortRead object by extracing the names, qualities and sequences of the reads themselves. What length are the reads?


<<>>=
sread(fq)
quality(fq)
id(fq)
table(width(fq))
@

Hopefully you will recognise the format that the reads are stored in. By using the Biostrings common infrastrucure, the operations we introduced earlier can be used on sequencing reads. Also, some commonly-used operations have been provided. A typical usage for reading fastq files is for quality assessment using the imported quality scores and seqeunces themselves. The \Rfunction{alphabetByCycle} function is provided as a convenience function to count the number of occurences of each base at each position in the read.


\usecase
Obtain a matrix of the base-frequency at each cycle and compare how it changes along the read by making separate lines for each base.


<<>>=
abc <- alphabetByCycle(sread(fq))
dim(abc)
plot(abc[1,],type="n",ylim=range(0,max(abc)))

text(abc[1,],labels="A",col="red")
text(abc[2,],labels="C",col="orange")
text(abc[3,],labels="G",col="green")
text(abc[4,],labels="T",col="blue")

@
\textinfo By using \Rcode{type='n'} we tell the \Rfunction{plot} function to create an empty plot with axes and labels, but no points. We add details to this empty plot using the \Rfunction{text} function.\\

\usecase
Calculate the GC content of each read using the \Rfunction{gcFunction} function in the {\tt scripts} folder. Find any reads with over 90\% GC bases

<<>>=

source("scripts/gcFunction.R")


gc <- gcFunction(sread(fq))
hist(gc)

sread(fq)[gc > 0.9]

@

We can also seek to find how many times each sequence occur in the file. Over-represented sequences could be adaptor sequences, or other artefacts.

\usecase
Find the most-commonly ocurring sequences in the file

<<>>=

tbl <- tables(fq)
names(tbl)
tbl$top[1:5]
tbl$distribution

@

If we see an unacceptable drop in quality at the end of a read, we may wish to trim the sequences before aligning.

\usecase
Convert the quality scores into a more manageable format and visualise the quality drop-off towards the end of the read.


<<>>=
qual <- as(quality(fq), "matrix")
dim(qual)
plot(colMeans(qual), type="b")
abline(h=26)
@

For illustration purposes, we will choose a minimum cut-off of 26. 

\usecase
Trim the sequences to ensure a mean quality of 26 and construct a new {\tt fastq} file from the trimmed sequences and qualities.


<<>>=

minQual <- 26
trimL <- min(which(colMeans(qual) < minQual))

trimmed.seq <- subseq(sread(fq),1,trimL)
trimmed.seq
quals <- subseq(quality(fq)@quality,1,trimL)

names(trimmed.seq) <- id(fq)
writeXStringSet(trimmed.seq, file="trimmed.fq", format="fastq",qualities=quals)
@



\section{Ranges and GRanges}
\subsection{Ranges}
\Rclass{IRanges} are another fundamental concept in Bioconductor used to represent consecutive integers. We will illustrate the usage of the package using simple illustrative examples before introducing genomic data later on.


\usecase
Construct an \Rclass{IRanges} object with start positions between 50 and 150 and varying lengths between 1 and 25

<<>>=
library(IRanges)
starts <- floor(runif(n=50,min=50,max=150))
ends <- starts + floor(runif(n=50,min=1,max=25))
query <- IRanges(start = starts, end=ends)
query <- sort(query)
@



A number of \textit{Intra-range} operations are implemented that act on each range independantly. You may find this function from UC Riverside HT-sequencing guide by Thomas Girke \footnote{http://manuals.bioinformatics.ucr.edu/home/ht-seq} useful in understanding the ranges objects.
<<>>=
source("scripts//plotRanges.R")
plotRanges
@

\usecase
Experiment with the basic operations \Rfunction{shift} and \Rfunction{resize}.

<<>>=
shift(query,5)
plotRanges(shift(query,5))
plotRanges(resize(query,4))
@


On the other hand, \textit{Inter-range} methods operate on a whole collection of ranges. Examples include \Rfunction{reduce}, \Rfunction{gaps} and \Rfunction{coverage}.

<<>>=
plotRanges(reduce(query))
@

Coverage (or sometimes depth) is the operation for calculating how many ranges overlap each position. In the \Biocpkg{IRanges} implementation of this calculation, the output is a Run-length encoding ({\tt RLE}).

\usecase
Calculate the coverage of the example IRanges object. Make sure you understand the run-length encoding output.


<<>>=
coverage(query)
plot(coverage(query))
@


Comparisons of \Rclass{IRanges} objects are crucial for many downstream analyses of sequencing data. e.g. counting reads within particular genes. Many such comparisons are supported by the \Biocpkg{IRanges} package. Typically, two sets of ranges are required; a \Robject{query} and a \Robject{subject}. However, the nature of the output depends on the function.

We will illustrate these functions by constructing windows that start at even intervals, but have varying length

\usecase
Define a series of windows that start at regular intervals between 30 and 160, but with varying lengths

<<>>=
start2 <- seq(30,160,by=10)
subject <- IRanges(start = start2, width=sample(1:10,length(start2),replace=T))
  
par(mfrow=c(3,1))
plotRanges(query,xlim=c(0,150))
plotRanges(subject,xlim=c(0,150))

@

\Rfunction{precede} and \Rfunction{follow} are two ways of comparing Ranges objects For each range in x, \Rfunction{precede} returns the index of the interval in \Robject{subject} that is directly preceded by the \Robject{query} range. Overlapping ranges are excluded. \Rcode{NA} is returned when there are no qualifying ranges in subject.

The opposite of \Rfunction{precede}, \Rfunction{follow} returns the index of the range in \Robject{subject} that a \Robject{query} range in x directly follows. Overlapping ranges are excluded. \Rcode{NA} is returned when there are no qualifying ranges in subject.


\usecase
Use \Rfunction{precede}, \Rfunction{follow} and \Rfunction{nearest} on the \Robject{query} and \Robject{subject} objects that we have created.

<<>>=
prec <- precede(query, subject) 
foll <- follow(query, subject) 
query[1:10]
subject[prec[1:10]]
subject[foll[1:10]]
nearest(query,subject)
@


The degree of overlap between \Robject{query} and \Robject{subject} ranges can be investigated in a number of ways.  The \Rfunction{findOverlaps} function is the simplest way of finding which intervals in one set overlap another. The returned object stored the indices of the query and subject ranges that overlap. The \Rfunction{countOverlaps} is a convenient way of counting the number of ranges in the query overlap with the subject. If we are interested in the actual ranges where an overlap occurs (or does not occur), we can use the \Rfunction{intersect} and \Rfunction{setdiff} functions.


\usecase
Investigate the degree of overlap between the \Robject{query} and \Robject{subject} ranges.


<<>>=
olaps <- findOverlaps(subject, query)
queryHits(olaps)
countOverlaps(query, subject)
countOverlaps(subject, query)


plotRanges(intersect(query,subject),xlim=c(0,200))
plotRanges(setdiff(query,subject),xlim=c(0,200))

@

\subsection{GRanges}

\Robject{GRanges} objects are an extension of IRanges that can incorporate Genomic information such as chromosome names (commonly called seqnames) and strand information.

\usecase
Construct a \Robject{GRanges} object from the query and subject data in the previous exercise, allocating each range to sequences \textbf{A}, \textbf{B} or \textbf{C}. Explore the relationship between the objects as in the previous exercises.

<<>>=
library(GenomicRanges)
gr <- GRanges(seqnames=sample(LETTERS[1:3],length(query),replace=T), ranges=query)
gr <- sort(gr)

gr2 <- GRanges(seqnames=sample(LETTERS[1:3],length(subject),replace=T), ranges=subject)
gr2 <- sort(gr2)
shift(gr,5)
reduce(gr)
gaps(gr)
gaps(gr2)
coverage(gr)
coverage(gr2)
@

\textinfo In later practicals, we will see how can perform overlaps of genomic features using this same infrastructure. 

\section{Reading bam alignments}
An obvious application of the \Rclass{IRanges} and \Rclass{GRanges} infrastructure is to facilitate the storage and querying of genomic alignments. The \Biocpkg{Rsamtools} is one such package that allows aligned reads to be imported into R. However, we will use functionality from the \Biocpkg{GenomicRanges} package for simplicity. In your own time, feel free to check out the \Rfunction{scanBam} function in \Biocpkg{Rsamtools}. 

An example bam file is provided in the {\tt exampleData} folder.


\usecase
Read the example bam file into R as a \Robject{GRanges} object. How many reads are in the file?


<<>>=
mybam <- "exampleData/NA19914.chr22.bam"
bam <- readGAlignments(file=mybam)
bam
@

The essential information from the bam file has been imported. Finer grain control over what data are read can be achieved by using the {\tt param} argument. The object returned by \Rfunction{readGAlignments} acts like a data frame, with columns that can be assessed by a number of convenience functions \Rfunction{strand}, \Rfunction{width}, \Rfunction{cigar}, \Rfunction{start}, \Rfunction{end}

\usecase
Use accessor ({\Rfunction{strand}, \Rfunction{width}, \Rfunction{cigar}, \Rfunction{start}, \Rfunction{end}) functions to explore the \Robject{bam} object.


<<>>=
table(strand(bam))
table(width(bam))
range(start(bam))
head(sort(table(cigar(bam)), decreasing=TRUE))
@



Several range operations will work on the GappedAlignment object, such as \Rfunction{coverage}.


\usecase
Create a coverage vector and identify regions with more than 1000 reads covering


<<>>=
cov <- coverage(bam)
HighCov <- ranges(slice(cov, 1000))[["22"]]
HighCov
@



An efficient way of creating a subset of reads based on genomic location is to use the overlapping functionality that we saw previously.

\usecase
Restrict the alignments to just those in the high-coverage (say > 1000 reads) regions


<<>>=
HighCovGR <- GRanges("22", IRanges(start = start(HighCov), end=end(HighCov)))
bam.sub <- bam[bam %over% HighCovGR,]
bam.sub
length(bam.sub)

@


\usecase
Use \Rfunction{findOverlaps} and \Rfunction{countOverlaps} to find out how many reads align to these high-coverage regions.

<<>>=
findOverlaps(HighCovGR,bam)
countOverlaps(HighCovGR,bam)
@


\subsection{Reading a particular genomic region}

If we were only really interested in a relatively small region of a chromosome, then another option would be to read the whole bam file, especially if the file can run to several gigabytes in size. As the bam file is indexed, we can easily jump to the location we are interested in. This is achieved by using the \Rfunction{ScanBamParam} function with the GRanges object for the region we want to read. See the help page on \Rfunction{ScanBamParam} for more details about how to customise how to read a bam file.




\usecase
Read a portion of the bam file corresponding to the high-coverage regions rather the whole file. Verify that the same reads as the previous exercise are returned.


<<>>=
bam.sub2 <- readGAlignments(file=mybam,use.names=TRUE, 
param=ScanBamParam(which=HighCovGR))
length(bam.sub)
length(bam.sub2)
all(names(bam.sub) == names(bam.sub2))
@

The previous two exercises have restricted the analysis to reads that fall inside any of the high-coverage regions. However, we might want to look at each region separately.


\usecase
Classify the reads according to which high-coverage region they belong to. Verify that the correct number of overlapping reads are returned.


<<>>=
names(HighCovGR) <- paste("Region", 1:length(HighCov),sep="")
regionLst <- split(HighCovGR, names(HighCovGR))

splitRegions <- lapply(regionLst, function(x) bam[bam %over% x])

lapply(splitRegions,length)

@



\end{document}
